/**
 * Adapted from vscode-markdown/src/toc.ts
 * https://github.com/yzhang-gh/vscode-markdown/blob/master/src/toc.ts
 */
"use strict";

import {
  CancellationToken,
  CodeLens,
  CodeLensProvider,
  commands,
  EndOfLine,
  ExtensionContext,
  languages,
  Range,
  TextEditor,
  TextDocument,
  TextDocumentWillSaveEvent,
  window,
  workspace,
  Position,
} from "vscode";

import { basename, dirname, relative } from "path";
import * as ws from "./workspace";

/**
 * Workspace config
 */
const docConfig = { tab: "  ", eol: "\r\n" };
const mdDocSelector = [
  { language: "markdown", scheme: "file" },
  { language: "markdown", scheme: "untitled" },
];

function loadDocConfig() {
  // Load workspace config
  let activeEditor = window.activeTextEditor;
  if (!activeEditor) {
    console.log("Failed to load config, no active editor");
    return;
  }

  docConfig.eol = activeEditor.document.eol === EndOfLine.CRLF ? "\r\n" : "\n";

  let tabSize = Number(activeEditor.options.tabSize);
  let insertSpaces = activeEditor.options.insertSpaces;
  if (insertSpaces) {
    docConfig.tab = " ".repeat(tabSize);
  } else {
    docConfig.tab = "\t";
  }
}

const REFERENCE_HEADER = `[//begin]: # "Autogenerated link references for markdown compatibility"`;
const REFERENCE_FOOTER = `[//end]: # "Autogenerated link references"`;

export function activate(context: ExtensionContext) {
  context.subscriptions.push(
    commands.registerCommand(
      "foam-vscode.update-wikilinks",
      updateReferenceList
    ),
    workspace.onWillSaveTextDocument(onWillSave),
    languages.registerCodeLensProvider(
      mdDocSelector,
      new WikilinkReferenceCodeLensProvider()
    )
  );
}

async function createReferenceList() {
  let editor = window.activeTextEditor;
  if (!editor || !isMdEditor(editor)) {
    return;
  }

  let refs = await generateReferenceList(editor.document);
  if (refs && refs.length) {
    await editor.edit(function (editBuilder) {
      if (editor) {
        const spacing = hasEmptyTrailing
          ? docConfig.eol
          : docConfig.eol + docConfig.eol;

        editBuilder.insert(
          new Position(editor.document.lineCount, 0),
          spacing + refs.join(docConfig.eol)
        );
      }
    });
  }
}

async function updateReferenceList() {
  const editor = window.activeTextEditor;

  if (!editor || !isMdEditor(editor)) {
    return;
  }

  loadDocConfig();

  const doc = editor.document;
  const range = detectReferenceListRange(doc);

  if (!range) {
    await createReferenceList();
  } else {
    const refs = await generateReferenceList(doc);

    // references must always be preceded by an empty line
    const spacing = doc.lineAt(range.start.line - 1).isEmptyOrWhitespace
      ? ""
      : docConfig.eol;

    await editor.edit((editBuilder) => {
      editBuilder.replace(range, spacing + refs.join(docConfig.eol));
    });
  }
}

async function generateReferenceList(doc: TextDocument): Promise<string[]> {
  const filePath = doc.fileName;

  const id = dropExtension(basename(filePath));

  // @todo fix hack
  await ws.ready;

  // update file in index for future reference
  // @todo should probably be an update method instead
  // so we can prune existing references
  ws.manager.addNoteFromMarkdown(filePath, doc.getText());

  // find note by id
  const note = ws.manager.getNoteWithLinks(id);

  if (note.linkedNotes.length === 0) {
    return [];
  }

  const references = [];

  for (const link of note.linkedNotes) {
    const relativePath = relative(dirname(filePath), link.absolutePath);
    if (relativePath) {
      const relativePathWithoutExtension = dropExtension(relativePath);

      // [wiki-link-text]: wiki-link "Page title"
      references.push(
        `[${link.id}]: ${relativePathWithoutExtension} "${link.title}"`
      );
    }
  }

  // for (const backlink of note.backlinks) {
  //   references.push(
  //     `[backlink:${backlink.id}]: ${backlink.filename} "${backlink.title}"`
  //   );
  // }

  return [REFERENCE_HEADER, ...references, REFERENCE_FOOTER];
}

/**
 * Find the range of existing reference list
 * @param doc
 */
function detectReferenceListRange(doc: TextDocument): Range {
  const fullText = doc.getText();

  const headerIndex = fullText.indexOf(REFERENCE_HEADER);
  const footerIndex = fullText.lastIndexOf(REFERENCE_FOOTER);

  if (headerIndex < 0) {
    return null;
  }

  const headerLine =
    fullText.substring(0, headerIndex).split(docConfig.eol).length - 1;

  const footerLine =
    fullText.substring(0, footerIndex).split(docConfig.eol).length - 1;

  if (headerLine >= footerLine) {
    return null;
  }

  return new Range(
    new Position(headerLine, 0),
    new Position(footerLine, REFERENCE_FOOTER.length)
  );
}

function onWillSave(e: TextDocumentWillSaveEvent) {
  if (e.document.languageId === "markdown") {
    e.waitUntil(updateReferenceList());
  }
}

function hasEmptyTrailing(doc: TextDocument): boolean {
  return doc.lineAt(doc.lineCount - 1).isEmptyOrWhitespace;
}

function getText(range: Range): string {
  return window.activeTextEditor.document.getText(range);
}

function isMdEditor(editor: TextEditor) {
  return editor && editor.document && editor.document.languageId === "markdown";
}

function dropExtension(path: string): string {
  const parts = path.split(".");
  parts.pop();
  return parts.join(".");
}

class WikilinkReferenceCodeLensProvider implements CodeLensProvider {
  public provideCodeLenses(
    document: TextDocument,
    _: CancellationToken
  ): CodeLens[] | Thenable<CodeLens[]> {
    loadDocConfig();

    let range = detectReferenceListRange(document);
    if (!range) {
      return [];
    }

    return generateReferenceList(document).then((refs) => {
      const oldRefs = getText(range).replace(/\r?\n|\r/g, docConfig.eol);
      const newRefs = refs.join(docConfig.eol);

      let status = oldRefs === newRefs ? "up to date" : "out of date";

      return [
        new CodeLens(range, {
          arguments: [],
          title: `Link references (${status})`,
          command: "",
        }),
      ];
    });
  }
}
