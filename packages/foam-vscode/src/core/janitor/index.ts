import { Resource } from '../model/note';
import { Range } from '../model/range';
import {
  createMarkdownReferences,
  stringifyMarkdownLinkReferenceDefinition,
} from '../services/markdown-provider';
import { getHeadingFromFileName } from '../utils';
import { FoamWorkspace } from '../model/workspace';
import detectNewline from 'detect-newline';
import { EOL } from 'os';

export const LINK_REFERENCE_DEFINITION_HEADER = `[//begin]: # "Autogenerated link references for markdown compatibility"`;
export const LINK_REFERENCE_DEFINITION_FOOTER = `[//end]: # "Autogenerated link references"`;

export interface TextEdit {
  range: Range;
  newText: string;
}

export const generateLinkReferences = async (
  note: Resource,
  text: string,
  eol: string,
  workspace: FoamWorkspace,
  includeExtensions: boolean
): Promise<TextEdit | null> => {
  if (!note) {
    return null;
  }

  const markdownReferences = createMarkdownReferences(
    workspace,
    note.uri,
    includeExtensions
  );

  const newReferences =
    markdownReferences.length === 0
      ? ''
      : [
          LINK_REFERENCE_DEFINITION_HEADER,
          ...markdownReferences.map(stringifyMarkdownLinkReferenceDefinition),
          LINK_REFERENCE_DEFINITION_FOOTER,
        ].join(eol);

  if (note.definitions.length === 0) {
    if (newReferences.length === 0) {
      return null;
    }

    const padding = note.source.end.character === 0 ? eol : `${eol}${eol}`;
    return {
      newText: `${padding}${newReferences}`,
      range: Range.createFromPosition(note.source.end, note.source.end),
    };
  } else {
    const first = note.definitions[0];
    const last = note.definitions[note.definitions.length - 1];

    let nonGeneratedReferenceDefinitions = note.definitions;

    // if we have more definitions then referenced pages AND the page refers to a page
    // we expect non-generated link definitions to be present
    // Collect all non-generated definitions, by removing the generated ones
    if (
      note.definitions.length > markdownReferences.length &&
      markdownReferences.length > 0
    ) {
      // remove all autogenerated definitions
      const beginIndex = note.definitions.findIndex(
        ({ label }) => label === '//begin'
      );
      const endIndex = note.definitions.findIndex(
        ({ label }) => label === '//end'
      );

      const generatedDefinitions = [...note.definitions].splice(
        beginIndex,
        endIndex - beginIndex + 1
      );

      nonGeneratedReferenceDefinitions = note.definitions.filter(
        x => !generatedDefinitions.includes(x)
      );
    }

    // When we only have explicitly defined link definitions &&
    // no indication of previously defined generated links &&
    // there is no reference to another page, return null
    if (
      nonGeneratedReferenceDefinitions.length > 0 &&
      note.definitions.findIndex(({ label }) => label === '//begin') < 0 &&
      markdownReferences.length === 0
    ) {
      return null;
    }

    // Format link definitions for non-generated links
    const nonGeneratedReferences = nonGeneratedReferenceDefinitions
      .map(stringifyMarkdownLinkReferenceDefinition)
      .join(eol);

    const oldReferences = note.definitions
      .map(stringifyMarkdownLinkReferenceDefinition)
      .join(eol);

    // When the newly formatted references match the old ones, OR
    // when non-generated references are present, but no new ones are generated
    // return null
    if (
      oldReferences === newReferences ||
      (nonGeneratedReferenceDefinitions.length > 0 &&
        newReferences === '' &&
        markdownReferences.length > 0)
    ) {
      return null;
    }

    let fullReferences = `${newReferences}`;
    // If there are any non-generated definitions, add those to the output as well
    if (
      nonGeneratedReferenceDefinitions.length > 0 &&
      markdownReferences.length > 0
    ) {
      fullReferences = `${nonGeneratedReferences}${eol}${newReferences}`;
    }

    return {
      // @todo: do we need to ensure new lines?
      newText: `${fullReferences}`,
      range: Range.createFromPosition(first.range!.start, last.range!.end),
    };
  }
};

export const generateHeading = async (
  note: Resource,
  workspace: FoamWorkspace,
  eol: string
): Promise<TextEdit | null> => {
  if (!note) {
    return null;
  }

  // TODO now the note.title defaults to file name at parsing time, so this check
  // doesn't work anymore. Decide:
  // - whether do we actually want to continue generate the headings
  // - whether it should be under a config option
  // A possible approach would be around having a `sections` field in the note, and inspect
  // it to see if there is an h1 title. Alternatively parse directly the markdown in this function.
  if (note.title) {
    return null;
  }

  const frontmatterExists = note.source.contentStart.line !== 1;

  let newLineExistsAfterFrontmatter = false;
  if (frontmatterExists) {
    const text = await workspace.readAsMarkdown(note.uri);
    const lines = text.split(eol);
    const index = note.source.contentStart.line - 1;
    const line = lines[index];
    newLineExistsAfterFrontmatter = line === '';
  }

  const paddingStart = frontmatterExists ? eol : '';
  const paddingEnd = newLineExistsAfterFrontmatter ? eol : `${eol}${eol}`;

  return {
    newText: `${paddingStart}# ${getHeadingFromFileName(
      note.uri.getName()
    )}${paddingEnd}`,
    range: Range.createFromPosition(
      note.source.contentStart,
      note.source.contentStart
    ),
  };
};
