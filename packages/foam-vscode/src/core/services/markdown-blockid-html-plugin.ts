import MarkdownIt from 'markdown-it';
import Token from 'markdown-it/lib/token';

const blockIdRegex = /\s*(\^[-_a-zA-Z0-9]+)\s*$/;

/**
 * A markdown-it plugin to handle inline block identifiers.
 * - For paragraphs and list items, it adds the block ID as the element's `id`.
 * - For headings, it adds a `span` with the block ID to coexist with the default slug-based ID.
 * - It removes the block ID from the rendered text in all cases.
 */
export function blockIdHtmlPlugin(
  md: MarkdownIt,
  _workspace?: any,
  _parser?: any
) {
  md.core.ruler.push('foam_block_id_inline', state => {
    const tokens = state.tokens;
    for (let i = 0; i < tokens.length; i++) {
      // We are looking for pattern: block_open, inline, block_close
      const openToken = tokens[i];
      const inlineToken = tokens[i + 1];
      const closeToken = tokens[i + 2];

      if (
        !inlineToken ||
        !closeToken ||
        inlineToken.type !== 'inline' ||
        openToken.nesting !== 1 ||
        closeToken.nesting !== -1
      ) {
        continue;
      }

      const match = inlineToken.content.match(blockIdRegex);
      if (!match) {
        continue;
      }

      const blockId = match[1]; // e.g. ^my-id
      const htmlId = blockId;

      let targetToken = openToken;
      // Special case for list items: find the parent <li> and move the ID there.
      if (
        openToken.type === 'paragraph_open' &&
        i > 0 &&
        tokens[i - 1].type === 'list_item_open'
      ) {
        targetToken = tokens[i - 1];
      }

      // Headings are handled by markdown-it-anchor, so we do nothing here.
      // The wikilink-navigation.ts will link to the slug generated by markdown-it-anchor.
      if (targetToken.type === 'heading_open') {
        // Do nothing for headings.
      }
      // For other block elements, we no longer add the ID directly to the opening tag
      // as we are linking to the nearest heading instead.

      // Clean the block ID from the text content for all types
      inlineToken.content = inlineToken.content.replace(blockIdRegex, '');
      if (inlineToken.children) {
        // Also clean from the last text child, which is where it will be
        const lastChild = inlineToken.children[inlineToken.children.length - 1];
        if (lastChild && lastChild.type === 'text') {
          lastChild.content = lastChild.content.replace(blockIdRegex, '');
        }
      }
    }
    return true;
  });
  return md;
}
