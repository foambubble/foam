import { NoteLinkDefinition, Resource, ResourceLink } from '../model/note';
import { Range } from '../model/range';
import { createMarkdownReferences } from '../services/markdown-provider';
import { FoamWorkspace } from '../model/workspace';
import { TextEdit } from '../services/text-edit';
import { getLinkDefinitions } from '../services/markdown-parser';

export const LINK_REFERENCE_DEFINITION_HEADER = `[//begin]: # "Autogenerated link references for markdown compatibility"`;
export const LINK_REFERENCE_DEFINITION_FOOTER = `[//end]: # "Autogenerated link references"`;

export const generateLinkReferences = async (
  note: Resource,
  currentNoteText: string,
  eol: string,
  workspace: FoamWorkspace,
  includeExtensions: boolean
): Promise<TextEdit[]> => {
  if (!note) {
    return [];
  }

  const nLines = currentNoteText.split(eol).length;

  const updatedWikilinkDefinitions = createMarkdownReferences(
    workspace,
    note,
    includeExtensions
  );

  const existingWikilinkDefinitions = getLinkDefinitions(currentNoteText);

  const toAddWikilinkDefinitions = updatedWikilinkDefinitions.filter(
    newDef =>
      !existingWikilinkDefinitions.some(
        existingDef => existingDef.label === newDef.label
      )
  );
  const toRemovedWikilinkDefinitions = existingWikilinkDefinitions.filter(
    existingDef =>
      !updatedWikilinkDefinitions.some(
        newDef => newDef.label === existingDef.label
      )
  );

  const edits: TextEdit[] = [];

  // Remove old definitions
  for (const def of toRemovedWikilinkDefinitions) {
    edits.push({ range: def.range, newText: '' });
  }

  // Add new definitions
  if (toAddWikilinkDefinitions.length > 0) {
    let text = '';
    for (const def of toAddWikilinkDefinitions) {
      // Choose the correct position for insertion, e.g., end of file or after last reference
      text = `${text}${eol}${NoteLinkDefinition.format(def)}`;
    }
    edits.push({
      range: Range.create(nLines - 1, 0, nLines - 1, 0),
      newText: text,
    });
  }

  // Optionally, handle updates to existing definitions if needed

  return edits;

  // const lines = text.split(eol);
  // // adjust padding based on whether there are existing definitions
  // // and, if not, whether we are on an empty line at the end of the file
  // const padding =
  //   updatedWikilinkDefinitions.length === 0 || // no definitions
  //   !Position.isEqual(targetRange.start, targetRange.end) // replace existing definitions
  //     ? ''
  //     : targetRange.start.character > 0 // not an empty line
  //     ? `${eol}${eol}`
  //     : eol;

  // return existingReferences === newReferences
  //   ? null
  //   : {
  //       newText: `${padding}${newReferences}`,
  //       range: targetRange,
  //     };
};
