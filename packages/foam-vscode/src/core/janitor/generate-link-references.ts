import { NoteLinkDefinition, Resource, ResourceLink } from '../model/note';
import { Range } from '../model/range';
import { createMarkdownReferences } from '../services/markdown-provider';
import { FoamWorkspace } from '../model/workspace';
import { TextEdit } from '../services/text-edit';
import { getLinkDefinitions } from '../services/markdown-parser';

export const LINK_REFERENCE_DEFINITION_HEADER = `[//begin]: # "Autogenerated link references for markdown compatibility"`;
export const LINK_REFERENCE_DEFINITION_FOOTER = `[//end]: # "Autogenerated link references"`;

export const generateLinkReferences = async (
  note: Resource,
  currentNoteText: string,
  eol: string,
  workspace: FoamWorkspace,
  includeExtensions: boolean
): Promise<TextEdit[]> => {
  if (!note) {
    return [];
  }

  const nLines = currentNoteText.split(eol).length;

  const updatedWikilinkDefinitions = createMarkdownReferences(
    workspace,
    note,
    includeExtensions
  );

  const existingWikilinkDefinitions = getLinkDefinitions(currentNoteText);

  const toAddWikilinkDefinitions = updatedWikilinkDefinitions.filter(
    newDef =>
      !existingWikilinkDefinitions.some(
        existingDef => existingDef.label === newDef.label
      )
  );
  const toRemovedWikilinkDefinitions = existingWikilinkDefinitions.filter(
    existingDef =>
      !updatedWikilinkDefinitions.some(
        newDef => newDef.label === existingDef.label
      )
  );

  const edits: TextEdit[] = [];

  // Remove old definitions
  for (const def of toRemovedWikilinkDefinitions) {
    edits.push({ range: def.range, newText: '' });
  }

  // Add new definitions
  if (toAddWikilinkDefinitions.length > 0) {
    const lastLine = currentNoteText.split(eol)[nLines - 1];
    const isLastLineEmpty = lastLine.trim().length === 0;

    let text = isLastLineEmpty ? '' : eol;
    for (const def of toAddWikilinkDefinitions) {
      // Choose the correct position for insertion, e.g., end of file or after last reference
      text = `${text}${eol}${NoteLinkDefinition.format(def)}`;
    }
    edits.push({
      range: Range.create(
        nLines - 1,
        lastLine.length,
        nLines - 1,
        lastLine.length
      ),
      newText: text,
    });
  }

  return edits;
};
